'use strict';

var cst = require('./cst.js');

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yii >  
 < / x s l : t e m p l a t e >  
  
 < x s l : t e m p l a t e   m a t c h = " m u l t i c a s t - a c t i v i t y - u p d a t e " >  
     < o s x m l : u p d a t e   c o n t r o l = " a c t i v i t y "   v a l u e = " { @ v a l u e } " / >  
 < / x s l : t e m p l a t e >  
  
 < x s l : t e m p l a t e   m a t c h = " b o o t m g r " >  
 < o s x m l : t e x t - m o d e - u i >  
     < h e a d >  
         < m e t a   k e y = " A N Y "   a c t i o n = " a n y k e y " / >  
         < m e t a   k e y = " F 8 "   a c t i o n = " a d v o p s " / >  
         < m e t a   k e y = " F 1 0 "   a c t i o n = " b o o t o p s " / >  
         < m e t a   k e y = " O E M K E Y "   a c t i o n = " o e m " / >  
     < / h e a d >  
 < / o s x m l : t e x t - m o d e - u i >  
 < / x s l : t e m p l a t e >  
  
 < x s l : t e m p l a t e   m a t c h = " b o o t m g r - c l e a r - s c r e e n " >  
 < o s x m l : t e x t - m o d e - u i >  
     < b o d y   b a c k g r o u n d - c o l o r = " X X X X "   f o r e g r o u n d - c o l o r = " R G B X " >  
     < b r / >  
     < / b o d y >  
 < / o s x m l : t e x t - m o d e - u i >  
 < / x s l : t e m p l a t e >  
  
 < x s l : t e m p l a t e   m a t c h = " * | @ * | t e x t ( ) " / >  
  
 < / x s l : s t y l e s h e e t >  
 PAPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPAD8!    0‚!+	*†H†÷ ‚!0‚!10	`†He 0\
+‚7 N0L0
+‚70	  ¢€ 010	`†He  Æ•($ç{N»&:2	Xç¢Vê¨C§~â+¦væ“ ‚
å0‚0‚î 3  2AûY™mÌMÿ    20	*†H†÷ 0„10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20110190502212436Z200502212436Z0p10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Windows0‚"0	*†H†÷ ‚ 0‚
‚ ’c[våúP( Ã\¯êf¶AõØu?ä`âæS9“dÉ )öKõG– úÊ¢ˆÌ®I;…÷W š¯ñ]~eÓØÀ¿æ.›}bgk#!Fé—àİı-èŞI„àOÕò|u nR¥aœj—‰è7°G7tïÆ¾×ƒÕ$é\õ;¡§¬. ùyÇÑvØd ü\CHxÔNMD6ıº[ñìğ>lÚÊÊ´’A,T¶4Å³ãÄªĞ¤T`7;š[˜E•ÍÚÒÀ“ñ–XÒp)ºTšÄ¾4¤0PçÓ:IÇµzr ‡jßÉÖ“HA1o7wªk²õ £‚‚0‚~0U%0
+‚7
+0U­«ËMõÖè3úìÚ¾¤çÑÅ»Z0TUM0K¤I0G1-0+U$Microsoft Ireland Operations Limited10U229879+4541120U#0€©)9Ä—xÍùOšá|U¯S0TUM0K0I G E†Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a+U0S0Q+0†Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0Uÿ0 0	*†H†÷ ‚ ®†ã‚î&ã*0iç:X|Ö
»p˜ØòTroW ÓyÂ@c ‹}§(ä{4…7 1]ÖRí¤Ç	Ş¿ĞI…V«‰@r§k8ß9Å^şz'×>ƒ,÷ı€ŞĞ½â/Â¡öÜÉ‰½ìh¿0Ó®E,[¾‘Ï«¼^xLDŸŠËE›6œÖİÜùÑÉFğ$GVŞ­Ş¾?=ó^,?2+ı!ç˜R“#é¯L+x`rÙø9L Ô­¸ƒŒÍ]àäÇwİõfê	R+«båÆfDÛï‡hœ™¶0'»­‡fF+;ï"F	íWqĞ—Ze¼D®n!w“0‚×0‚¿ 
avV     0	*†H†÷ 0ˆ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100111019184142Z261019185142Z0„10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20110‚"0	*†H†÷ ‚ 0‚
‚ İ»¢ä.	ãçÅ÷–i¼ !½i33ï­ËT€îƒ»Å „Ù÷Ò‹ó8°«¤­-|byÿãJ?5 pãÄçkàœÀ6uéŠ1İpåÜ7µtF–([‡`#,¿ÜG¥g÷Q'rë¦É¹;S5|åÓì'¹‡ş¹É#	o¨F‘Án–<AÓË£?]jMìi%(\6ÿıC
”à´ÏßÂâÂ['î'x0‹[*	k"‰S`,ÀhSºìIóaŒ…h	sD]}¢T+İy÷Ï5]l+\Î¼œ#‹onµ&Ù6ÃOÖ'®¹2;A’,áÇÍwèªTN÷\‡e´C¨²àmwìZ$úH £‚C0‚?0	+‚7 0U©)9Ä—xÍùOšá|U¯S0	+‚7
 S u b C A0U†0Uÿ0ÿ0U#0€ÕöVËè¢\bhÑ=”[×ÎšÄ0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*†H†÷ ‚ ü|qQ¥yÂn²ï9>¼<Rn+?sş¨hĞH¦4MŠ–&î1FayÖÿ8.EkôÀå(¸ÚŠÛ	×ÇL
6fjŒì×¨¤›¹â@26vÄÁZÆ¿äÀêÓ¬Ãhïb¬İTlP0X¦ë|ş”§Nôì|†sWÂR!s4Zó£ŠVÈÚ	íø‹ãÎô~®ğöŠû?ÉrS¸ë¾càã=1e°åò¬Í¤Ÿ=¨±›ÂBĞ„_Tÿ‰êºGo°sNAŸ@Ÿ_å¡*²‘sŠ!(ğÎŞs9_>«\`ìß¨Ó	éôö–…¶QˆfG¢°=*hw»‘Lb{¶ÁÇºz‡4Kbz™éÊüÎJ7É-¤W|ş=Ü¸ZúÖÄ³…:ê³Ùnäi!7ŞÑöugÓ“W^)9Èî-áÍäEs[ĞÒÎz«‚FXĞ^³g¯l5ò¼å?$â5¢
uöV™Ôx,ÑëĞˆªñßº~,c·›#!ÄùxlâX6+‘Ì¤Ùò-ºù”@íEñÎŠ\k>«Óp*
jà_GÑÕc
2ò¯×6*pZåBYqKWº~ƒğ!<ôÁÅ¹“ˆE“†é± ™¾˜ËÅ•¤]bÖ c ½uw}=óE¹Ÿ—ŸËW€o3©Ïw¤bY~1‚¹0‚µ0œ0„10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20113  2AûY™mÌMÿ    20	`†He  ‚0	*†H†÷	1
+‚70
+‚710
+‚70/	*†H†÷	1" ;„Ó—Cw§‚ó¾o¼ùò™di61[Y3ÈP¿0Åı0<
+‚7
1.,DoAOwwDTNsZPDldNw1RUJSAIGv4Me4hbupbp2iAZ17Q=0Z
+‚71L0J $€" M i c r o s o f t   W i n d o w s¡"€ http://www.microsoft.com/windows0	*†H†÷ ‚ ‘Á›^…³š ®6f¦“Úi´tÑó'h²í79F±s‘pú‡¬söÍ&é‚ëÆŞ„ğ4ÍÊ9éÑ@©•ˆ~õ#'ÓnRº¼sÄñô¼šù¾œ³ó¯¿È|ÒãòúÎCUl­Îÿ’Û&È,Ã«Íá¥º4~bûS  Û'7©5Tr{Ñ±7£±Â|À¡×Ş¢¬tlÆöÉ˜éÃY—iq¨#”ûVgš”=èûŞ¨Su­}ZAbì:AAÆI*vÏ˜W“õÁóì	Ø˜Æ”	+ U'¢¢T¦5‰³6²&­7K$¶$\G¸Ü5–,ã-NXÔz^/ş»kzï¡‚å0‚á
+‚71‚Ñ0‚Í	*†H†÷ ‚¾0‚º10	`†He 0‚Q*†H†÷	 ‚@‚<0‚8
+„Y
010	`†He  Åh‰æR£ ¹z@¾U
m%}Ë?wn9/Åõdÿ®]è£™ş20191207004451.957Z0€ô Ğ¤Í0Ê10	UUS10	UWA10URedmond10U
Microsoft Corporation1-0+U$Microsoft Ireland Operations Limited1&0$UThales TSS ESN:A240-4B82-130E1%0#UMicrosoft Time-Stamp Service ‚<0‚ñ0‚Ù 3  îÔíÔ    0	*†H†÷ 0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100191023231920Z210121231920Z0Ê10	UUS10	UWA10URedmond10U
Microsoft Corporation1-0+U$Microsoft Ireland Operations Limited1&0$UThales TSS ESN:A240-4B82-130E1%0#UMicrosoft Time-Stamp Service0‚"0	*†H†÷ ‚ 0‚
‚ £Ò‚Ái‹î–åÙ”7› Å…Y¥ùäOßsï¨yçÏ×›R¸S[±WpGœ—³åÍÎu¹è/`ÃÑ{%•VLÅhE0İ°ÅUê*‰sºHéwĞèQ Îk:	×‹Ğv
ï\ÌGõñ_ôçHÿ i{i{g‘Ïî°$6>‡M©Çloëªò§OEE0<ò¢)â	•˜×ZÖuŒ†2KÄS–6|sipyZG£ğ¬¨<“#ø:lYÚÇV×UÖWÿ­¥êCOñPF&áeNı†&Ğ™å {öğn#}ÖL™ÓoŒ´qÕ6vÓ/ £‚0‚0UúpŞA¨vXÃÃĞWPß¶ùò0U#0€Õc:\Š1óC{|FÅ3hZ…mU0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicTimStaPCA_2010-07-01.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicTimStaPCA_2010-07-01.crt0Uÿ0 0U%0
+0	*†H†÷ ‚ †k]D˜®â”^W†Á‘Ãc¶~q4§>y¸ãY=õm.B5ÔUîŞà¸Ü6ŒL?lÏD%ëÔM7$÷8•ì×Vá;%XßÌõ¯¼2öWÅ—L¬i×h6´Á´(¸z³23€\„=š!à ½.Í>Ïà}ÂddMc	q±{$´«ãx}<ëâ‰4İFÖsÂˆb²àâæ]À–8{¶YL2fXuÈ"‘8­…‘×´”
ñŞSº°ªdÂsV¼³Mò#ƒ%u}Qz8¬Qæ»‰M¹Ce¬Û‘„cëÂÂ!{ê]zÎ¤nòW—.˜cˆTÁ#AààtäñFƒ0‚q0‚Y 
a	*     0	*†H†÷ 0ˆ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100100701213655Z2507012